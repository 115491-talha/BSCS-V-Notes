## **CC-311 — Operating Systems (General Definitions with Examples)**

---

### **1. Introduction to Operating Systems**

* **Operating System (OS):** Software that manages hardware and software resources and provides services to users and applications.
  *Example:* Windows, Linux, macOS.*

* **Kernel:** Core part of an OS that manages CPU, memory, and devices.

* **System Call:** Interface allowing user programs to request OS services.
  *Example:* `read()` or `write()` functions in C.*

* **Resource Management:** Allocation and control of CPU, memory, and I/O devices among processes.

* **Process:** A program in execution.
  *Example:* When you open Chrome, each tab runs as a process.*

* **Thread:** The smallest unit of CPU execution within a process.

* **Multiprogramming:** Running multiple programs concurrently by sharing CPU time.

* **Multitasking:** Executing multiple tasks seemingly at the same time.
  *Example:* Listening to music while browsing.*

* **Multithreading:** Running multiple threads within the same process.

* **System Protection:** Mechanism to prevent unauthorized access to resources.

---

### **2. Process Management**

* **Process State:** Current condition of a process (New, Ready, Running, Waiting, Terminated).

* **Process Control Block (PCB):** Data structure that stores process information like state, registers, and program counter.

* **Context Switching:** Saving and restoring CPU states when switching between processes.

* **Scheduling:** Deciding which process gets CPU time next.

* **CPU Burst:** Time a process spends executing on CPU before I/O.

* **Scheduling Criteria:** Metrics like turnaround time, waiting time, and response time used to evaluate schedulers.

* **Preemptive Scheduling:** CPU can be taken away from a process before it finishes.
  *Example:* Priority scheduling with interrupts.*

* **Non-Preemptive Scheduling:** Process keeps CPU until it completes or waits voluntarily.

* **Scheduling Algorithms:**

  * **FCFS:** Executes processes in arrival order.
  * **SJF:** Executes the shortest job first.
  * **Priority Scheduling:** Based on priority value.
  * **SRTF:** Preemptive version of SJF.
  * **Round Robin:** Time-slice-based scheduling.

* **Gantt Chart:** Timeline diagram showing execution order of processes.

---

### **3. Threads and Multithreading**

* **Thread:** A lightweight process sharing resources of its parent process.

* **Multithreading Models:**

  * **Many-to-One:** Multiple user threads map to one kernel thread.
  * **One-to-One:** Each user thread maps to a kernel thread.
  * **Many-to-Many:** Many user threads mapped to multiple kernel threads.

* **User-Level Threads:** Managed by user libraries, not the OS.

* **Kernel-Level Threads:** Managed directly by the OS.

* **Thread Scheduling:** Allocation of CPU to threads instead of processes.

* **Multiple Processor Scheduling:** Scheduling processes across multiple CPUs.

---

### **4. Process Synchronization**

* **Synchronization:** Coordination among processes to ensure correct shared resource access.
  *Example:* Two threads writing to the same file simultaneously.*

* **Critical Section:** Code segment where shared resources are accessed.

* **Race Condition:** When multiple processes modify shared data simultaneously, causing errors.

* **Mutual Exclusion:** Ensures only one process enters critical section at a time.

* **Peterson’s Solution:** Software-based algorithm for two-process synchronization.

* **Semaphore:** Integer variable used for synchronization (wait & signal operations).

* **Mutex (Mutual Exclusion Lock):** Binary lock used to control access to shared data.

* **Monitor:** High-level synchronization construct with condition variables.

* **Classical Synchronization Problems:**

  * **Producer-Consumer Problem:** Shared buffer coordination.
  * **Reader-Writer Problem:** Reading and writing shared data safely.
  * **Dining Philosophers Problem:** Preventing deadlock while sharing resources.

---

### **5. Deadlocks**

* **Deadlock:** Situation where processes wait indefinitely for resources held by each other.
  *Example:* Two programs each holding a resource the other needs.*

* **Deadlock Conditions:**

  1. Mutual Exclusion
  2. Hold and Wait
  3. No Preemption
  4. Circular Wait

* **Deadlock Prevention:** Preventing one of the conditions above.

* **Deadlock Avoidance:** Ensuring system never enters unsafe state (Banker’s Algorithm).

* **Deadlock Detection:** Finding cycles in the resource allocation graph.

* **Deadlock Recovery:** Terminating or preempting processes to resolve deadlock.

---

### **6. Memory Management**

* **Memory Management:** Handling allocation and deallocation of main memory.

* **Logical Address:** Generated by CPU during program execution.

* **Physical Address:** Actual location in memory.

* **Swapping:** Moving processes between main memory and secondary storage.

* **Contiguous Allocation:** Assigning continuous memory blocks to a process.

* **Fragmentation:** Wastage of memory due to allocation method.

  * **Internal Fragmentation:** Unused space within allocated blocks.
  * **External Fragmentation:** Small free spaces scattered in memory.

* **Segmentation:** Dividing memory into logical segments (code, data, stack).

* **Paging:** Dividing memory into fixed-size pages and frames.

* **Virtual Memory:** Technique allowing execution of processes larger than main memory.

* **Demand Paging:** Loading pages only when needed.

* **Page Fault:** Occurs when required page isn’t in memory.

* **Page Replacement Algorithms:**

  * FIFO
  * LRU
  * Optimal

* **Thrashing:** Excessive paging causing performance degradation.

* **Memory-Mapped Files:** Files mapped into virtual memory for faster I/O access.

---

### **7. File System Management**

* **File:** Collection of related data stored on a disk.
  *Example:* Word document or image file.*

* **File Attributes:** Metadata such as name, size, type, and permissions.

* **File Operations:** Create, read, write, delete, and rename.

* **Directory Structure:** Organizes files for easy access.

  * Single-level, two-level, tree-structured directories.

* **Disk Structure:** Logical layout of data on a storage device.

* **Directory Implementation:**

  * Linear list
  * Hash table

* **File Allocation Methods:**

  * Contiguous
  * Linked
  * Indexed

* **Free Space Management:** Keeping track of unused disk blocks.

* **Disk Scheduling Algorithms:**

  * FCFS
  * SSTF
  * SCAN / C-SCAN
  * LOOK / C-LOOK

* **Swap Space Management:** Allocating disk space for swapped memory pages.

---

### **8. Protection and Security**

* **Protection:** Mechanisms controlling access to system resources.

* **Access Matrix:** Model defining rights of subjects over objects.

* **Domain of Protection:** Specifies permissible operations for each user or process.

* **Security:** Safeguarding system from unauthorized access and attacks.

* **Authentication:** Verifying user identity (passwords, biometrics).

* **Encryption:** Encoding data to prevent unauthorized access.
  *Example:* HTTPS encrypts data between browser and server.*

* **Auditing:** Recording user activities for security analysis.

---

### **9. Virtual Machines**

* **Virtual Machine (VM):** Software-based emulation of a physical computer.
  *Example:* Running Linux inside Windows using VMware.*

* **System VM:** Emulates complete hardware for running an OS.

* **Process VM:** Runs a single program (e.g., Java Virtual Machine).

* **Virtualization:** Running multiple OS environments on one machine.

---

### **10. OS Security (Advanced)**

* **Security Kernel:** Core component enforcing security policies.

* **Trusted Operating System:** OS with built-in mechanisms for security and integrity.

* **Secure Boot:** Verifies software integrity during system startup.

* **Intrusion Detection System (IDS):** Monitors system for unauthorized activity.

---
