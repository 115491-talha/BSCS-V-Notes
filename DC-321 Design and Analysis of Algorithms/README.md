### **DC-321 Design & Analysis of Algorithms — Complete Topic Breakdown**

#### **1. Introduction to Algorithms**

* **What is an Algorithm?**

  * Definition, importance, and real-world applications
* **Role of Algorithms in Computing**

  * Efficiency and optimization in problem-solving
* **Algorithm Specification**

  * Input/output characteristics
  * Finiteness, correctness, and feasibility
* **Algorithm vs Program**

---

#### **2. Analysis of Algorithms**

* **Performance Analysis**

  * Space complexity
  * Time complexity
* **Asymptotic Notations**

  * Big-O (Upper Bound)
  * Big-Ω (Lower Bound)
  * Big-Θ (Tight Bound)
  * little-o, little-ω (Non-tight bounds)
* **Order of Growth**

  * Constant, logarithmic, linear, quadratic, exponential
* **Analysis Based on Input**

  * Best-case, worst-case, average-case analysis
  * Nature and size of input

---

#### **3. Recursion and Recurrence Relations**

* **Concept of Recursion**

  * Direct and indirect recursion
* **Solving Recurrence Relations**

  * Substitution method
  * Iteration (expansion) method
  * Master theorem
* **Examples**

  * Recursive algorithms (factorial, Fibonacci, binary search, etc.)

---

#### **4. Sorting Algorithm Analysis**

* **Basics of Sorting**

  * Internal vs external sorting
  * Stable vs unstable sorting
* **Sorting Algorithms**

  * Bubble sort
  * Insertion sort
  * Selection sort
  * Merge sort
  * Quick sort
  * Heap sort
* **Loop Invariants**

  * Concept and use in proving correctness
* **Comparative Analysis**

  * Time and space complexity of each sorting algorithm

---

#### **5. Algorithm Design Techniques**

##### **(A) Brute Force Approach**

* Concept and characteristics
* Examples: Linear search, Selection sort, String matching

##### **(B) Divide and Conquer**

* Concept and strategy steps

  * Divide → Conquer → Combine
* Examples:

  * Merge sort
  * Quick sort
  * Binary search
  * Matrix multiplication (Strassen’s algorithm)

##### **(C) Greedy Approach**

* Idea of local vs global optimum
* Characteristics of greedy algorithms
* Examples:

  * Fractional knapsack problem
  * Job sequencing with deadlines
  * Huffman coding
  * Prim’s and Kruskal’s algorithms

##### **(D) Dynamic Programming**

* Concept and difference from divide and conquer
* Stages in dynamic programming

  * Characterize optimal substructure
  * Define recursive relation
  * Compute bottom-up
* Examples:

  * 0/1 Knapsack
  * Matrix chain multiplication
  * Longest common subsequence (LCS)
  * Optimal binary search tree

---

#### **6. Data Structures for Efficient Algorithms**

* **Search Trees**

  * Binary search trees (BSTs)
  * AVL trees (Rotations and balancing)
* **Heaps**

  * Min-heaps and max-heaps
  * Heap operations (insert, extract-min, heapify)
  * Applications (heap sort, priority queues)
* **Hashing**

  * Hash functions
  * Collision resolution techniques (chaining, open addressing)
  * Load factor and rehashing

---

#### **7. Graph Algorithms**

* **Representation of Graphs**

  * Adjacency matrix and adjacency list
* **Graph Traversal**

  * BFS (Breadth-First Search)
  * DFS (Depth-First Search)
* **Shortest Path Algorithms**

  * Dijkstra’s algorithm
  * Bellman-Ford algorithm
* **Minimum Spanning Trees**

  * Prim’s algorithm
  * Kruskal’s algorithm
* **Topological Sorting**

  * DAGs and ordering of tasks
* **Applications**

  * Network routing, scheduling, connectivity

---

#### **8. String Matching Algorithms**

* **Basic String Operations**

  * Pattern searching and substring matching
* **Algorithms**

  * Naive string matching
  * Knuth-Morris-Pratt (KMP) algorithm
  * Rabin-Karp algorithm
  * Finite automata-based matching

---

#### **9. Complexity Classes**

* **Introduction to Computational Complexity**

  * Classification of problems based on difficulty
* **P and NP Problems**

  * Definition and examples
* **NP-Complete and NP-Hard Problems**

  * Reduction and verification concepts
* **Tractable vs Intractable Problems**

---

✅ **Summary of Major Domains:**

1. Fundamentals and analysis of algorithms
2. Recursion and recurrence relations
3. Sorting techniques
4. Algorithm design paradigms (Brute Force, D&C, Greedy, DP)
5. Data structures (Trees, Heaps, Hashing)
6. Graph algorithms
7. String algorithms
8. Complexity theory

---
